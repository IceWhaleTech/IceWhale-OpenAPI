/* tslint:disable */
/* eslint-disable */
/**
 * CasaOS Installer API
 * API for installing and updating CasaOS on a device
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface BaseResponse
 */
export interface BaseResponse {
    /**
     * message returned by server side if there is any
     * @type {string}
     * @memberof BaseResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface BaseResponse1
 */
export interface BaseResponse1 {
    /**
     * message returned by server side if there is any
     * @type {string}
     * @memberof BaseResponse1
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface BaseResponse2
 */
export interface BaseResponse2 {
    /**
     * message returned by server side if there is any
     * @type {string}
     * @memberof BaseResponse2
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Chilren
 */
export interface Chilren {
    /**
     * 
     * @type {string}
     * @memberof Chilren
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Chilren
     */
    'mount_point'?: string;
    /**
     * 
     * @type {string}
     * @memberof Chilren
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof Chilren
     */
    'storage_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Chilren
     */
    'size'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Chilren
     */
    'supported'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Chilren
     */
    'file_system'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Chilren
     */
    'raid'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Chilren
     */
    'raid_level'?: number;
}
/**
 * 
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * 
     * @type {boolean}
     * @memberof Device
     */
    'health'?: boolean;
    /**
     * Whether the disk is faulty in RAID
     * @type {boolean}
     * @memberof Device
     */
    'faulty'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'path'?: string;
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    'index'?: number;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'model'?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface Disk
 */
export interface Disk {
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    'storage_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Disk
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    'model'?: string;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    'health'?: string;
    /**
     * 
     * @type {number}
     * @memberof Disk
     */
    'temperature'?: number;
    /**
     * 
     * @type {DiskType}
     * @memberof Disk
     */
    'type'?: DiskType;
    /**
     * 
     * @type {boolean}
     * @memberof Disk
     */
    'need_format'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    'serial'?: string;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    'path'?: string;
    /**
     * 
     * @type {number}
     * @memberof Disk
     */
    'children_number'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Disk
     */
    'support'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Disk
     */
    'index'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Disk
     */
    'free'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    'usage'?: string;
    /**
     * 
     * @type {Array<Chilren>}
     * @memberof Disk
     */
    'children'?: Array<Chilren>;
    /**
     * 
     * @type {boolean}
     * @memberof Disk
     */
    'rota'?: boolean;
}


/**
 * 
 * @export
 * @interface DiskInfo
 */
export interface DiskInfo {
    /**
     * 
     * @type {Disk}
     * @memberof DiskInfo
     */
    'disk'?: Disk;
    /**
     * 
     * @type {Array<Partition>}
     * @memberof DiskInfo
     */
    'partitions'?: Array<Partition>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DiskType = {
    Hdd: 'HDD',
    Ssd: 'SSD',
    Usb: 'USB',
    Nvme: 'NVME',
    Mmc: 'MMC'
} as const;

export type DiskType = typeof DiskType[keyof typeof DiskType];


/**
 * 
 * @export
 * @interface GetDiskInfo200Response
 */
export interface GetDiskInfo200Response {
    /**
     * message returned by server side if there is any
     * @type {string}
     * @memberof GetDiskInfo200Response
     */
    'message'?: string;
    /**
     * 
     * @type {DiskInfo}
     * @memberof GetDiskInfo200Response
     */
    'data'?: DiskInfo;
}
/**
 * 
 * @export
 * @interface GetDisks200Response
 */
export interface GetDisks200Response {
    /**
     * message returned by server side if there is any
     * @type {string}
     * @memberof GetDisks200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Array<Disk>}
     * @memberof GetDisks200Response
     */
    'data'?: Array<Disk>;
}
/**
 * 
 * @export
 * @interface GetInstall200Response
 */
export interface GetInstall200Response {
    /**
     * message returned by server side if there is any
     * @type {string}
     * @memberof GetInstall200Response
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetInstall200Response
     */
    'path'?: string;
}
/**
 * 
 * @export
 * @interface GetMergeInitStatus200Response
 */
export interface GetMergeInitStatus200Response {
    /**
     * message returned by server side if there is any
     * @type {string}
     * @memberof GetMergeInitStatus200Response
     */
    'message'?: string;
    /**
     * 
     * @type {MergeStatus}
     * @memberof GetMergeInitStatus200Response
     */
    'data'?: MergeStatus;
}


/**
 * 
 * @export
 * @interface GetMerges200Response
 */
export interface GetMerges200Response {
    /**
     * message returned by server side if there is any
     * @type {string}
     * @memberof GetMerges200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Array<Merge>}
     * @memberof GetMerges200Response
     */
    'data'?: Array<Merge>;
}
/**
 * 
 * @export
 * @interface GetMounts200Response
 */
export interface GetMounts200Response {
    /**
     * message returned by server side if there is any
     * @type {string}
     * @memberof GetMounts200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Array<Mount>}
     * @memberof GetMounts200Response
     */
    'data'?: Array<Mount>;
}
/**
 * 
 * @export
 * @interface GetNoticeInfo200Response
 */
export interface GetNoticeInfo200Response {
    /**
     * message returned by server side if there is any
     * @type {string}
     * @memberof GetNoticeInfo200Response
     */
    'message'?: string;
    /**
     * 
     * @type {NoticeInfoOKData}
     * @memberof GetNoticeInfo200Response
     */
    'data'?: NoticeInfoOKData;
}


/**
 * 
 * @export
 * @interface GetRaids200Response
 */
export interface GetRaids200Response {
    /**
     * message returned by server side if there is any
     * @type {string}
     * @memberof GetRaids200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Array<Raid>}
     * @memberof GetRaids200Response
     */
    'data'?: Array<Raid>;
}
/**
 * 
 * @export
 * @interface GetRelease200Response
 */
export interface GetRelease200Response {
    /**
     * message returned by server side if there is any
     * @type {string}
     * @memberof GetRelease200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Release}
     * @memberof GetRelease200Response
     */
    'data'?: Release;
    /**
     * 
     * @type {boolean}
     * @memberof GetRelease200Response
     */
    'upgradable'?: boolean;
}
/**
 * 
 * @export
 * @interface GetStatus200Response
 */
export interface GetStatus200Response {
    /**
     * message returned by server side if there is any
     * @type {string}
     * @memberof GetStatus200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Status}
     * @memberof GetStatus200Response
     */
    'data'?: Status;
}
/**
 * 
 * @export
 * @interface GetStorage200Response
 */
export interface GetStorage200Response {
    /**
     * message returned by server side if there is any
     * @type {string}
     * @memberof GetStorage200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Array<Storage>}
     * @memberof GetStorage200Response
     */
    'data'?: Array<Storage>;
}
/**
 * 
 * @export
 * @interface Merge
 */
export interface Merge {
    /**
     * 
     * @type {number}
     * @memberof Merge
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Merge
     */
    'fstype'?: string;
    /**
     * 
     * @type {string}
     * @memberof Merge
     */
    'mount_point': string;
    /**
     * 
     * @type {string}
     * @memberof Merge
     */
    'source_base_path'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Merge
     */
    'source_volume_uuids'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Merge
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Merge
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MergeStatus = {
    Initialized: 'initialized',
    Uninitialized: 'uninitialized',
    Error: 'error'
} as const;

export type MergeStatus = typeof MergeStatus[keyof typeof MergeStatus];


/**
 * 
 * @export
 * @interface Module
 */
export interface Module {
    /**
     * 
     * @type {string}
     * @memberof Module
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Module
     */
    'short': string;
}
/**
 * 
 * @export
 * @interface Mount
 */
export interface Mount {
    /**
     * 
     * @type {number}
     * @memberof Mount
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Mount
     */
    'mount_point': string;
    /**
     * 
     * @type {string}
     * @memberof Mount
     */
    'fstype'?: string;
    /**
     * 
     * @type {string}
     * @memberof Mount
     */
    'source'?: string;
    /**
     * 
     * @type {string}
     * @memberof Mount
     */
    'options'?: string;
    /**
     * Extended properties of the mount
     * @type {{ [key: string]: string; }}
     * @memberof Mount
     */
    'extended'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface MountPoint
 */
export interface MountPoint {
    /**
     * 
     * @type {string}
     * @memberof MountPoint
     */
    'mount_point': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const NoticeInfoOKData = {
    NoUpdate: 'no-update',
    NormalUpdate: 'normal-update',
    ImportantUpdate: 'important-update',
    ForceUpdate: 'force-update'
} as const;

export type NoticeInfoOKData = typeof NoticeInfoOKData[keyof typeof NoticeInfoOKData];


/**
 * 
 * @export
 * @interface Package
 */
export interface Package {
    /**
     * 
     * @type {string}
     * @memberof Package
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof Package
     */
    'architecture': PackageArchitectureEnum;
}

export const PackageArchitectureEnum = {
    Amd64: 'amd64',
    Arm64: 'arm64',
    Arm7: 'arm-7'
} as const;

export type PackageArchitectureEnum = typeof PackageArchitectureEnum[keyof typeof PackageArchitectureEnum];

/**
 * 
 * @export
 * @interface Partition
 */
export interface Partition {
    /**
     * 
     * @type {string}
     * @memberof Partition
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Partition
     */
    'size'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Partition
     */
    'supported'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Partition
     */
    'FileSystem'?: string;
}
/**
 * 
 * @export
 * @interface PostStorageBody
 */
export interface PostStorageBody {
    /**
     * 
     * @type {string}
     * @memberof PostStorageBody
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof PostStorageBody
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof PostStorageBody
     */
    'format'?: boolean;
}
/**
 * 
 * @export
 * @interface PutRaidBody
 */
export interface PutRaidBody {
    /**
     * 
     * @type {string}
     * @memberof PutRaidBody
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof PutRaidBody
     */
    'action'?: PutRaidBodyActionEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof PutRaidBody
     */
    'devices'?: Array<string>;
}

export const PutRaidBodyActionEnum = {
    Add: 'add',
    Remove: 'remove'
} as const;

export type PutRaidBodyActionEnum = typeof PutRaidBodyActionEnum[keyof typeof PutRaidBodyActionEnum];

/**
 * 
 * @export
 * @interface PutSystemUSBAutoMountRequest
 */
export interface PutSystemUSBAutoMountRequest {
    /**
     * USB auto-mounting state
     * @type {string}
     * @memberof PutSystemUSBAutoMountRequest
     */
    'state'?: string;
}
/**
 * 
 * @export
 * @interface Raid
 */
export interface Raid {
    /**
     * 
     * @type {string}
     * @memberof Raid
     */
    'name'?: string;
    /**
     * 
     * @type {Array<Device>}
     * @memberof Raid
     */
    'devices'?: Array<Device>;
    /**
     * 
     * @type {string}
     * @memberof Raid
     */
    'mount_point'?: string;
    /**
     * 
     * @type {number}
     * @memberof Raid
     */
    'raid_level'?: number;
    /**
     * 
     * @type {number}
     * @memberof Raid
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof Raid
     */
    'used'?: number;
    /**
     * 
     * @type {number}
     * @memberof Raid
     */
    'percentage'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Raid
     */
    'shortage'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Raid
     */
    'damaged'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Raid
     */
    'finish_time'?: number;
    /**
     * 
     * @type {string}
     * @memberof Raid
     */
    'path'?: string;
    /**
     * 
     * @type {number}
     * @memberof Raid
     */
    'disk_number'?: number;
    /**
     * 
     * @type {string}
     * @memberof Raid
     */
    'status'?: RaidStatusEnum;
    /**
     * The size of the smallest disk in RAID.
     * @type {number}
     * @memberof Raid
     */
    'dev_size'?: number;
}

export const RaidStatusEnum = {
    Recover: 'recover',
    Idle: 'idle',
    Reshape: 'reshape'
} as const;

export type RaidStatusEnum = typeof RaidStatusEnum[keyof typeof RaidStatusEnum];

/**
 * 
 * @export
 * @interface RaidBody
 */
export interface RaidBody {
    /**
     * 
     * @type {Array<string>}
     * @memberof RaidBody
     */
    'devices': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof RaidBody
     */
    'raid_level': RaidBodyRaidLevelEnum;
    /**
     * Whether to replace the existing /DATA directory
     * @type {boolean}
     * @memberof RaidBody
     */
    'is_default'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RaidBody
     */
    'mount_point'?: string;
    /**
     * 
     * @type {string}
     * @memberof RaidBody
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RaidBody
     */
    'path'?: string;
}

export const RaidBodyRaidLevelEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_5: 5
} as const;

export type RaidBodyRaidLevelEnum = typeof RaidBodyRaidLevelEnum[keyof typeof RaidBodyRaidLevelEnum];

/**
 * 
 * @export
 * @interface Release
 */
export interface Release {
    /**
     * 
     * @type {string}
     * @memberof Release
     */
    'version': string;
    /**
     * 
     * @type {string}
     * @memberof Release
     */
    'release_notes': string;
    /**
     * 
     * @type {string}
     * @memberof Release
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof Release
     */
    'background'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Release
     */
    'important'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Release
     */
    'mirrors': Array<string>;
    /**
     * 
     * @type {Array<Package>}
     * @memberof Release
     */
    'packages': Array<Package>;
    /**
     * 
     * @type {string}
     * @memberof Release
     */
    'checksums': string;
    /**
     * 
     * @type {Array<Module>}
     * @memberof Release
     */
    'modules': Array<Module>;
}
/**
 * 
 * @export
 * @interface SetMerge200Response
 */
export interface SetMerge200Response {
    /**
     * message returned by server side if there is any
     * @type {string}
     * @memberof SetMerge200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Merge}
     * @memberof SetMerge200Response
     */
    'data'?: Merge;
}
/**
 * 
 * @export
 * @interface Status
 */
export interface Status {
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'status': StatusStatusEnum;
}

export const StatusStatusEnum = {
    Idle: 'idle',
    FetchUpdating: 'fetchUpdating',
    FetchError: 'fetchError',
    Downloading: 'downloading',
    DownloadError: 'downloadError',
    Installing: 'installing',
    InstallError: 'installError'
} as const;

export type StatusStatusEnum = typeof StatusStatusEnum[keyof typeof StatusStatusEnum];

/**
 * 
 * @export
 * @interface Storage
 */
export interface Storage {
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    'mount_point'?: string;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    'size'?: string;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    'avail'?: string;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    'used'?: string;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    'drive_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    'persisted_in'?: string;
    /**
     * 
     * @type {DiskType}
     * @memberof Storage
     */
    'disk_type'?: DiskType;
    /**
     * 
     * @type {boolean}
     * @memberof Storage
     */
    'raid'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Storage
     */
    'raid_level'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Storage
     */
    'health'?: boolean;
}


/**
 * 
 * @export
 * @interface StorageAggrgation
 */
export interface StorageAggrgation {
    /**
     * 
     * @type {string}
     * @memberof StorageAggrgation
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof StorageAggrgation
     */
    'font': string;
    /**
     * 
     * @type {string}
     * @memberof StorageAggrgation
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof StorageAggrgation
     */
    'type': StorageAggrgationTypeEnum;
    /**
     * extensions
     * @type {object}
     * @memberof StorageAggrgation
     */
    'extensions': object;
}

export const StorageAggrgationTypeEnum = {
    Raid: 'raid',
    System: 'system',
    Usb: 'USB',
    Disk: 'disk',
    Cloud: 'cloud',
    Smb: 'smb'
} as const;

export type StorageAggrgationTypeEnum = typeof StorageAggrgationTypeEnum[keyof typeof StorageAggrgationTypeEnum];

/**
 * 
 * @export
 * @interface UpdateMount200Response
 */
export interface UpdateMount200Response {
    /**
     * message returned by server side if there is any
     * @type {string}
     * @memberof UpdateMount200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Mount}
     * @memberof UpdateMount200Response
     */
    'data'?: Mount;
}
/**
 * 
 * @export
 * @interface Volume
 */
export interface Volume {
    /**
     * 
     * @type {number}
     * @memberof Volume
     */
    'id'?: number;
    /**
     * (TODO)
     * @type {string}
     * @memberof Volume
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof Volume
     */
    'path': string;
    /**
     * (TODO)
     * @type {number}
     * @memberof Volume
     */
    'state'?: number;
    /**
     * 
     * @type {string}
     * @memberof Volume
     */
    'mount_point': string;
    /**
     * 
     * @type {string}
     * @memberof Volume
     */
    'created_at'?: string;
}

/**
 * CommonMethodsApi - axios parameter creator
 * @export
 */
export const CommonMethodsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the Info of the installation. such as install package path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstall: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/install`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the status of the OTA program.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Install a release of CasaOS
         * @param {string} [version] version of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installRelease: async (version?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/release`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommonMethodsApi - functional programming interface
 * @export
 */
export const CommonMethodsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommonMethodsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the Info of the installation. such as install package path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstall(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInstall200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInstall(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommonMethodsApi.getInstall']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the status of the OTA program.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommonMethodsApi.getStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Install a release of CasaOS
         * @param {string} [version] version of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async installRelease(version?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.installRelease(version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommonMethodsApi.installRelease']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CommonMethodsApi - factory interface
 * @export
 */
export const CommonMethodsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommonMethodsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the Info of the installation. such as install package path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstall(options?: RawAxiosRequestConfig): AxiosPromise<GetInstall200Response> {
            return localVarFp.getInstall(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the status of the OTA program.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getStatus(options?: RawAxiosRequestConfig): AxiosPromise<GetStatus200Response> {
            return localVarFp.getStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Install a release of CasaOS
         * @param {string} [version] version of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installRelease(version?: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
            return localVarFp.installRelease(version, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommonMethodsApi - object-oriented interface
 * @export
 * @class CommonMethodsApi
 * @extends {BaseAPI}
 */
export class CommonMethodsApi extends BaseAPI {
    /**
     * 
     * @summary Get the Info of the installation. such as install package path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonMethodsApi
     */
    public getInstall(options?: RawAxiosRequestConfig) {
        return CommonMethodsApiFp(this.configuration).getInstall(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the status of the OTA program.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof CommonMethodsApi
     */
    public getStatus(options?: RawAxiosRequestConfig) {
        return CommonMethodsApiFp(this.configuration).getStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Install a release of CasaOS
     * @param {string} [version] version of the release
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonMethodsApi
     */
    public installRelease(version?: string, options?: RawAxiosRequestConfig) {
        return CommonMethodsApiFp(this.configuration).installRelease(version, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DiskMethodsApi - axios parameter creator
 * @export
 */
export const DiskMethodsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of all disks, or a single disk by path.
         * @summary Get disk info
         * @param {string} [path] Filter the results by path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiskInfo: async (path?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/disk/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all disks, or a single disk by path.
         * @summary Get disks
         * @param {string} [free] Filter the results by path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisks: async (free?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/disk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (free !== undefined) {
                localVarQueryParameter['free'] = free;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DiskMethodsApi - functional programming interface
 * @export
 */
export const DiskMethodsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DiskMethodsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of all disks, or a single disk by path.
         * @summary Get disk info
         * @param {string} [path] Filter the results by path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDiskInfo(path?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDiskInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDiskInfo(path, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DiskMethodsApi.getDiskInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of all disks, or a single disk by path.
         * @summary Get disks
         * @param {string} [free] Filter the results by path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDisks(free?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDisks200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDisks(free, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DiskMethodsApi.getDisks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DiskMethodsApi - factory interface
 * @export
 */
export const DiskMethodsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DiskMethodsApiFp(configuration)
    return {
        /**
         * Get a list of all disks, or a single disk by path.
         * @summary Get disk info
         * @param {string} [path] Filter the results by path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiskInfo(path?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetDiskInfo200Response> {
            return localVarFp.getDiskInfo(path, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all disks, or a single disk by path.
         * @summary Get disks
         * @param {string} [free] Filter the results by path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisks(free?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetDisks200Response> {
            return localVarFp.getDisks(free, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DiskMethodsApi - object-oriented interface
 * @export
 * @class DiskMethodsApi
 * @extends {BaseAPI}
 */
export class DiskMethodsApi extends BaseAPI {
    /**
     * Get a list of all disks, or a single disk by path.
     * @summary Get disk info
     * @param {string} [path] Filter the results by path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiskMethodsApi
     */
    public getDiskInfo(path?: string, options?: RawAxiosRequestConfig) {
        return DiskMethodsApiFp(this.configuration).getDiskInfo(path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all disks, or a single disk by path.
     * @summary Get disks
     * @param {string} [free] Filter the results by path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiskMethodsApi
     */
    public getDisks(free?: string, options?: RawAxiosRequestConfig) {
        return DiskMethodsApiFp(this.configuration).getDisks(free, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MergeMethodsApi - axios parameter creator
 * @export
 */
export const MergeMethodsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * (TODO)
         * @summary Get merge initialization status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMergeInitStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/merge/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (TODO)
         * @summary Get merges
         * @param {string} [mountPoint] Filter the results by mount point
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerges: async (mountPoint?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/merge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (mountPoint !== undefined) {
                localVarQueryParameter['mount_point'] = mountPoint;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (TODO)
         * @summary Initialize a merge
         * @param {MountPoint} mountPoint 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initMerge: async (mountPoint: MountPoint, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mountPoint' is not null or undefined
            assertParamExists('initMerge', 'mountPoint', mountPoint)
            const localVarPath = `/merge/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mountPoint, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (TODO)
         * @summary Set a merge
         * @param {Merge} merge 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMerge: async (merge: Merge, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'merge' is not null or undefined
            assertParamExists('setMerge', 'merge', merge)
            const localVarPath = `/merge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(merge, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MergeMethodsApi - functional programming interface
 * @export
 */
export const MergeMethodsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MergeMethodsApiAxiosParamCreator(configuration)
    return {
        /**
         * (TODO)
         * @summary Get merge initialization status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMergeInitStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMergeInitStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMergeInitStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MergeMethodsApi.getMergeInitStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * (TODO)
         * @summary Get merges
         * @param {string} [mountPoint] Filter the results by mount point
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMerges(mountPoint?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMerges200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMerges(mountPoint, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MergeMethodsApi.getMerges']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * (TODO)
         * @summary Initialize a merge
         * @param {MountPoint} mountPoint 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initMerge(mountPoint: MountPoint, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMergeInitStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initMerge(mountPoint, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MergeMethodsApi.initMerge']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * (TODO)
         * @summary Set a merge
         * @param {Merge} merge 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setMerge(merge: Merge, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetMerge200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setMerge(merge, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MergeMethodsApi.setMerge']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MergeMethodsApi - factory interface
 * @export
 */
export const MergeMethodsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MergeMethodsApiFp(configuration)
    return {
        /**
         * (TODO)
         * @summary Get merge initialization status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMergeInitStatus(options?: RawAxiosRequestConfig): AxiosPromise<GetMergeInitStatus200Response> {
            return localVarFp.getMergeInitStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * (TODO)
         * @summary Get merges
         * @param {string} [mountPoint] Filter the results by mount point
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerges(mountPoint?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetMerges200Response> {
            return localVarFp.getMerges(mountPoint, options).then((request) => request(axios, basePath));
        },
        /**
         * (TODO)
         * @summary Initialize a merge
         * @param {MountPoint} mountPoint 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initMerge(mountPoint: MountPoint, options?: RawAxiosRequestConfig): AxiosPromise<GetMergeInitStatus200Response> {
            return localVarFp.initMerge(mountPoint, options).then((request) => request(axios, basePath));
        },
        /**
         * (TODO)
         * @summary Set a merge
         * @param {Merge} merge 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMerge(merge: Merge, options?: RawAxiosRequestConfig): AxiosPromise<SetMerge200Response> {
            return localVarFp.setMerge(merge, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MergeMethodsApi - object-oriented interface
 * @export
 * @class MergeMethodsApi
 * @extends {BaseAPI}
 */
export class MergeMethodsApi extends BaseAPI {
    /**
     * (TODO)
     * @summary Get merge initialization status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MergeMethodsApi
     */
    public getMergeInitStatus(options?: RawAxiosRequestConfig) {
        return MergeMethodsApiFp(this.configuration).getMergeInitStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * (TODO)
     * @summary Get merges
     * @param {string} [mountPoint] Filter the results by mount point
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MergeMethodsApi
     */
    public getMerges(mountPoint?: string, options?: RawAxiosRequestConfig) {
        return MergeMethodsApiFp(this.configuration).getMerges(mountPoint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * (TODO)
     * @summary Initialize a merge
     * @param {MountPoint} mountPoint 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MergeMethodsApi
     */
    public initMerge(mountPoint: MountPoint, options?: RawAxiosRequestConfig) {
        return MergeMethodsApiFp(this.configuration).initMerge(mountPoint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * (TODO)
     * @summary Set a merge
     * @param {Merge} merge 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MergeMethodsApi
     */
    public setMerge(merge: Merge, options?: RawAxiosRequestConfig) {
        return MergeMethodsApiFp(this.configuration).setMerge(merge, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MountMethodsApi - axios parameter creator
 * @export
 */
export const MountMethodsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all volumes currently mounted on the system. Volumes can be filtered by corresponding query parameters.
         * @summary Get mounted volumes
         * @param {string} [id] Filter the results by id
         * @param {string} [mountPoint] Filter the results by mount point
         * @param {string} [type] Filter the results by type
         * @param {string} [source] Filter the results by source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMounts: async (id?: string, mountPoint?: string, type?: string, source?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (mountPoint !== undefined) {
                localVarQueryParameter['mount_point'] = mountPoint;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (TODO)
         * @summary Mount a volume
         * @param {Mount} mount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mount: async (mount: Mount, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mount' is not null or undefined
            assertParamExists('mount', 'mount', mount)
            const localVarPath = `/mount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (TODO)
         * @summary Umount volume
         * @param {string} mountPoint Filter the results by mount point
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umount: async (mountPoint: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mountPoint' is not null or undefined
            assertParamExists('umount', 'mountPoint', mountPoint)
            const localVarPath = `/mount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (mountPoint !== undefined) {
                localVarQueryParameter['mount_point'] = mountPoint;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updating a mount volume is equivalent to unmounting the volume and mounting it again with the new parameters.
         * @summary Update a mount volume
         * @param {string} mountPoint Filter the results by mount point
         * @param {Mount} mount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMount: async (mountPoint: string, mount: Mount, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mountPoint' is not null or undefined
            assertParamExists('updateMount', 'mountPoint', mountPoint)
            // verify required parameter 'mount' is not null or undefined
            assertParamExists('updateMount', 'mount', mount)
            const localVarPath = `/mount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (mountPoint !== undefined) {
                localVarQueryParameter['mount_point'] = mountPoint;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MountMethodsApi - functional programming interface
 * @export
 */
export const MountMethodsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MountMethodsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all volumes currently mounted on the system. Volumes can be filtered by corresponding query parameters.
         * @summary Get mounted volumes
         * @param {string} [id] Filter the results by id
         * @param {string} [mountPoint] Filter the results by mount point
         * @param {string} [type] Filter the results by type
         * @param {string} [source] Filter the results by source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMounts(id?: string, mountPoint?: string, type?: string, source?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMounts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMounts(id, mountPoint, type, source, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MountMethodsApi.getMounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * (TODO)
         * @summary Mount a volume
         * @param {Mount} mount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mount(mount: Mount, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateMount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mount(mount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MountMethodsApi.mount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * (TODO)
         * @summary Umount volume
         * @param {string} mountPoint Filter the results by mount point
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umount(mountPoint: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umount(mountPoint, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MountMethodsApi.umount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updating a mount volume is equivalent to unmounting the volume and mounting it again with the new parameters.
         * @summary Update a mount volume
         * @param {string} mountPoint Filter the results by mount point
         * @param {Mount} mount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMount(mountPoint: string, mount: Mount, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateMount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMount(mountPoint, mount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MountMethodsApi.updateMount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MountMethodsApi - factory interface
 * @export
 */
export const MountMethodsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MountMethodsApiFp(configuration)
    return {
        /**
         * Get all volumes currently mounted on the system. Volumes can be filtered by corresponding query parameters.
         * @summary Get mounted volumes
         * @param {string} [id] Filter the results by id
         * @param {string} [mountPoint] Filter the results by mount point
         * @param {string} [type] Filter the results by type
         * @param {string} [source] Filter the results by source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMounts(id?: string, mountPoint?: string, type?: string, source?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetMounts200Response> {
            return localVarFp.getMounts(id, mountPoint, type, source, options).then((request) => request(axios, basePath));
        },
        /**
         * (TODO)
         * @summary Mount a volume
         * @param {Mount} mount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mount(mount: Mount, options?: RawAxiosRequestConfig): AxiosPromise<UpdateMount200Response> {
            return localVarFp.mount(mount, options).then((request) => request(axios, basePath));
        },
        /**
         * (TODO)
         * @summary Umount volume
         * @param {string} mountPoint Filter the results by mount point
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umount(mountPoint: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse1> {
            return localVarFp.umount(mountPoint, options).then((request) => request(axios, basePath));
        },
        /**
         * Updating a mount volume is equivalent to unmounting the volume and mounting it again with the new parameters.
         * @summary Update a mount volume
         * @param {string} mountPoint Filter the results by mount point
         * @param {Mount} mount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMount(mountPoint: string, mount: Mount, options?: RawAxiosRequestConfig): AxiosPromise<UpdateMount200Response> {
            return localVarFp.updateMount(mountPoint, mount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MountMethodsApi - object-oriented interface
 * @export
 * @class MountMethodsApi
 * @extends {BaseAPI}
 */
export class MountMethodsApi extends BaseAPI {
    /**
     * Get all volumes currently mounted on the system. Volumes can be filtered by corresponding query parameters.
     * @summary Get mounted volumes
     * @param {string} [id] Filter the results by id
     * @param {string} [mountPoint] Filter the results by mount point
     * @param {string} [type] Filter the results by type
     * @param {string} [source] Filter the results by source
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MountMethodsApi
     */
    public getMounts(id?: string, mountPoint?: string, type?: string, source?: string, options?: RawAxiosRequestConfig) {
        return MountMethodsApiFp(this.configuration).getMounts(id, mountPoint, type, source, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * (TODO)
     * @summary Mount a volume
     * @param {Mount} mount 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MountMethodsApi
     */
    public mount(mount: Mount, options?: RawAxiosRequestConfig) {
        return MountMethodsApiFp(this.configuration).mount(mount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * (TODO)
     * @summary Umount volume
     * @param {string} mountPoint Filter the results by mount point
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MountMethodsApi
     */
    public umount(mountPoint: string, options?: RawAxiosRequestConfig) {
        return MountMethodsApiFp(this.configuration).umount(mountPoint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updating a mount volume is equivalent to unmounting the volume and mounting it again with the new parameters.
     * @summary Update a mount volume
     * @param {string} mountPoint Filter the results by mount point
     * @param {Mount} mount 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MountMethodsApi
     */
    public updateMount(mountPoint: string, mount: Mount, options?: RawAxiosRequestConfig) {
        return MountMethodsApiFp(this.configuration).updateMount(mountPoint, mount, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OTAMethodsApi - axios parameter creator
 * @export
 */
export const OTAMethodsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the background image of the latest release
         * @param {string} [version] version of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackground: async (version?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/background`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the Info of the installation. such as install package path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstall: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/install`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the notice info of Update Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNoticeInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/web/notice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the information about the latest release of CasaOS
         * @param {string} [version] version of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelease: async (version?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/release`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the status of the OTA program.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Install a release of CasaOS
         * @param {string} [version] version of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installRelease: async (version?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/release`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change error status to idle
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        resetStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OTAMethodsApi - functional programming interface
 * @export
 */
export const OTAMethodsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OTAMethodsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the background image of the latest release
         * @param {string} [version] version of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBackground(version?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBackground(version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OTAMethodsApi.getBackground']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the Info of the installation. such as install package path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInstall(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInstall200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInstall(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OTAMethodsApi.getInstall']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the notice info of Update Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNoticeInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetNoticeInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNoticeInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OTAMethodsApi.getNoticeInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the information about the latest release of CasaOS
         * @param {string} [version] version of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelease(version?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRelease200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelease(version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OTAMethodsApi.getRelease']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the status of the OTA program.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async getStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OTAMethodsApi.getStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Install a release of CasaOS
         * @param {string} [version] version of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async installRelease(version?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.installRelease(version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OTAMethodsApi.installRelease']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Change error status to idle
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async resetStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OTAMethodsApi.resetStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OTAMethodsApi - factory interface
 * @export
 */
export const OTAMethodsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OTAMethodsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the background image of the latest release
         * @param {string} [version] version of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackground(version?: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.getBackground(version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the Info of the installation. such as install package path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInstall(options?: RawAxiosRequestConfig): AxiosPromise<GetInstall200Response> {
            return localVarFp.getInstall(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the notice info of Update Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNoticeInfo(options?: RawAxiosRequestConfig): AxiosPromise<GetNoticeInfo200Response> {
            return localVarFp.getNoticeInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the information about the latest release of CasaOS
         * @param {string} [version] version of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelease(version?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetRelease200Response> {
            return localVarFp.getRelease(version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the status of the OTA program.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        getStatus(options?: RawAxiosRequestConfig): AxiosPromise<GetStatus200Response> {
            return localVarFp.getStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Install a release of CasaOS
         * @param {string} [version] version of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installRelease(version?: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
            return localVarFp.installRelease(version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change error status to idle
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        resetStatus(options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
            return localVarFp.resetStatus(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OTAMethodsApi - object-oriented interface
 * @export
 * @class OTAMethodsApi
 * @extends {BaseAPI}
 */
export class OTAMethodsApi extends BaseAPI {
    /**
     * 
     * @summary Get the background image of the latest release
     * @param {string} [version] version of the release
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OTAMethodsApi
     */
    public getBackground(version?: string, options?: RawAxiosRequestConfig) {
        return OTAMethodsApiFp(this.configuration).getBackground(version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the Info of the installation. such as install package path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OTAMethodsApi
     */
    public getInstall(options?: RawAxiosRequestConfig) {
        return OTAMethodsApiFp(this.configuration).getInstall(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the notice info of Update Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OTAMethodsApi
     */
    public getNoticeInfo(options?: RawAxiosRequestConfig) {
        return OTAMethodsApiFp(this.configuration).getNoticeInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the information about the latest release of CasaOS
     * @param {string} [version] version of the release
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OTAMethodsApi
     */
    public getRelease(version?: string, options?: RawAxiosRequestConfig) {
        return OTAMethodsApiFp(this.configuration).getRelease(version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the status of the OTA program.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OTAMethodsApi
     */
    public getStatus(options?: RawAxiosRequestConfig) {
        return OTAMethodsApiFp(this.configuration).getStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Install a release of CasaOS
     * @param {string} [version] version of the release
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OTAMethodsApi
     */
    public installRelease(version?: string, options?: RawAxiosRequestConfig) {
        return OTAMethodsApiFp(this.configuration).installRelease(version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change error status to idle
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OTAMethodsApi
     */
    public resetStatus(options?: RawAxiosRequestConfig) {
        return OTAMethodsApiFp(this.configuration).resetStatus(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RaidMethodsApi - axios parameter creator
 * @export
 */
export const RaidMethodsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a raid
         * @summary create a raid
         * @param {RaidBody} raidBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRaid: async (raidBody: RaidBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'raidBody' is not null or undefined
            assertParamExists('createRaid', 'raidBody', raidBody)
            const localVarPath = `/raid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(raidBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a raid by path
         * @summary Delete a raid
         * @param {string} path Filter the delete by raid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRaid: async (path: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'path' is not null or undefined
            assertParamExists('deleteRaid', 'path', path)
            const localVarPath = `/raid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all raids, or a single raid by name.
         * @summary Get raids
         * @param {string} [path] Filter the results by raid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaids: async (path?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/raid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update raid-related configurations by name
         * @summary Update a raid
         * @param {PutRaidBody} putRaidBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRaid: async (putRaidBody: PutRaidBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'putRaidBody' is not null or undefined
            assertParamExists('updateRaid', 'putRaidBody', putRaidBody)
            const localVarPath = `/raid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(putRaidBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RaidMethodsApi - functional programming interface
 * @export
 */
export const RaidMethodsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RaidMethodsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a raid
         * @summary create a raid
         * @param {RaidBody} raidBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRaid(raidBody: RaidBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Raid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRaid(raidBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaidMethodsApi.createRaid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a raid by path
         * @summary Delete a raid
         * @param {string} path Filter the delete by raid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRaid(path: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRaid(path, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaidMethodsApi.deleteRaid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of all raids, or a single raid by name.
         * @summary Get raids
         * @param {string} [path] Filter the results by raid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRaids(path?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRaids200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRaids(path, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaidMethodsApi.getRaids']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update raid-related configurations by name
         * @summary Update a raid
         * @param {PutRaidBody} putRaidBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRaid(putRaidBody: PutRaidBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Raid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRaid(putRaidBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaidMethodsApi.updateRaid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RaidMethodsApi - factory interface
 * @export
 */
export const RaidMethodsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RaidMethodsApiFp(configuration)
    return {
        /**
         * Create a raid
         * @summary create a raid
         * @param {RaidBody} raidBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRaid(raidBody: RaidBody, options?: RawAxiosRequestConfig): AxiosPromise<Raid> {
            return localVarFp.createRaid(raidBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a raid by path
         * @summary Delete a raid
         * @param {string} path Filter the delete by raid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRaid(path: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse1> {
            return localVarFp.deleteRaid(path, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all raids, or a single raid by name.
         * @summary Get raids
         * @param {string} [path] Filter the results by raid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaids(path?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetRaids200Response> {
            return localVarFp.getRaids(path, options).then((request) => request(axios, basePath));
        },
        /**
         * Update raid-related configurations by name
         * @summary Update a raid
         * @param {PutRaidBody} putRaidBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRaid(putRaidBody: PutRaidBody, options?: RawAxiosRequestConfig): AxiosPromise<Raid> {
            return localVarFp.updateRaid(putRaidBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RaidMethodsApi - object-oriented interface
 * @export
 * @class RaidMethodsApi
 * @extends {BaseAPI}
 */
export class RaidMethodsApi extends BaseAPI {
    /**
     * Create a raid
     * @summary create a raid
     * @param {RaidBody} raidBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaidMethodsApi
     */
    public createRaid(raidBody: RaidBody, options?: RawAxiosRequestConfig) {
        return RaidMethodsApiFp(this.configuration).createRaid(raidBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a raid by path
     * @summary Delete a raid
     * @param {string} path Filter the delete by raid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaidMethodsApi
     */
    public deleteRaid(path: string, options?: RawAxiosRequestConfig) {
        return RaidMethodsApiFp(this.configuration).deleteRaid(path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all raids, or a single raid by name.
     * @summary Get raids
     * @param {string} [path] Filter the results by raid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaidMethodsApi
     */
    public getRaids(path?: string, options?: RawAxiosRequestConfig) {
        return RaidMethodsApiFp(this.configuration).getRaids(path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update raid-related configurations by name
     * @summary Update a raid
     * @param {PutRaidBody} putRaidBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaidMethodsApi
     */
    public updateRaid(putRaidBody: PutRaidBody, options?: RawAxiosRequestConfig) {
        return RaidMethodsApiFp(this.configuration).updateRaid(putRaidBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StorageMethodsApi - axios parameter creator
 * @export
 */
export const StorageMethodsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a storage
         * @summary Create a storage
         * @param {PostStorageBody} postStorageBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStorage: async (postStorageBody: PostStorageBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postStorageBody' is not null or undefined
            assertParamExists('createStorage', 'postStorageBody', postStorageBody)
            const localVarPath = `/storage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postStorageBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a storage by path
         * @summary Delete a storage
         * @param {string} path Filter the delete by path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStorage: async (path: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'path' is not null or undefined
            assertParamExists('deleteStorage', 'path', path)
            const localVarPath = `/storage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all storage, or a single storage by path.
         * @summary Get all storages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllStorages: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/storages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all storage, or a single storage by path.
         * @summary Get storages
         * @param {string} [system] Whether system storage is required
         * @param {string} [path] Filter the results by path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorage: async (system?: string, path?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/storage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (system !== undefined) {
                localVarQueryParameter['system'] = system;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StorageMethodsApi - functional programming interface
 * @export
 */
export const StorageMethodsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StorageMethodsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a storage
         * @summary Create a storage
         * @param {PostStorageBody} postStorageBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStorage(postStorageBody: PostStorageBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostStorageBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStorage(postStorageBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StorageMethodsApi.createStorage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a storage by path
         * @summary Delete a storage
         * @param {string} path Filter the delete by path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStorage(path: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStorage(path, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StorageMethodsApi.deleteStorage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of all storage, or a single storage by path.
         * @summary Get all storages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllStorages(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StorageAggrgation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllStorages(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StorageMethodsApi.getAllStorages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of all storage, or a single storage by path.
         * @summary Get storages
         * @param {string} [system] Whether system storage is required
         * @param {string} [path] Filter the results by path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStorage(system?: string, path?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStorage200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStorage(system, path, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StorageMethodsApi.getStorage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StorageMethodsApi - factory interface
 * @export
 */
export const StorageMethodsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StorageMethodsApiFp(configuration)
    return {
        /**
         * Create a storage
         * @summary Create a storage
         * @param {PostStorageBody} postStorageBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStorage(postStorageBody: PostStorageBody, options?: RawAxiosRequestConfig): AxiosPromise<PostStorageBody> {
            return localVarFp.createStorage(postStorageBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a storage by path
         * @summary Delete a storage
         * @param {string} path Filter the delete by path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStorage(path: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse1> {
            return localVarFp.deleteStorage(path, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all storage, or a single storage by path.
         * @summary Get all storages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllStorages(options?: RawAxiosRequestConfig): AxiosPromise<Array<StorageAggrgation>> {
            return localVarFp.getAllStorages(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all storage, or a single storage by path.
         * @summary Get storages
         * @param {string} [system] Whether system storage is required
         * @param {string} [path] Filter the results by path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorage(system?: string, path?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetStorage200Response> {
            return localVarFp.getStorage(system, path, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StorageMethodsApi - object-oriented interface
 * @export
 * @class StorageMethodsApi
 * @extends {BaseAPI}
 */
export class StorageMethodsApi extends BaseAPI {
    /**
     * Create a storage
     * @summary Create a storage
     * @param {PostStorageBody} postStorageBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageMethodsApi
     */
    public createStorage(postStorageBody: PostStorageBody, options?: RawAxiosRequestConfig) {
        return StorageMethodsApiFp(this.configuration).createStorage(postStorageBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a storage by path
     * @summary Delete a storage
     * @param {string} path Filter the delete by path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageMethodsApi
     */
    public deleteStorage(path: string, options?: RawAxiosRequestConfig) {
        return StorageMethodsApiFp(this.configuration).deleteStorage(path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all storage, or a single storage by path.
     * @summary Get all storages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageMethodsApi
     */
    public getAllStorages(options?: RawAxiosRequestConfig) {
        return StorageMethodsApiFp(this.configuration).getAllStorages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all storage, or a single storage by path.
     * @summary Get storages
     * @param {string} [system] Whether system storage is required
     * @param {string} [path] Filter the results by path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageMethodsApi
     */
    public getStorage(system?: string, path?: string, options?: RawAxiosRequestConfig) {
        return StorageMethodsApiFp(this.configuration).getStorage(system, path, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * USBMethodsApi - axios parameter creator
 * @export
 */
export const USBMethodsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get system USB auto-mount state
         * @summary Get USB auto-mounting status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemUSBAutoMount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/usb/usb-auto-mount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable or disable USB auto-mounting.
         * @summary Enable or disable USB auto-mounting
         * @param {PutSystemUSBAutoMountRequest} [putSystemUSBAutoMountRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSystemUSBAutoMount: async (putSystemUSBAutoMountRequest?: PutSystemUSBAutoMountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/usb/usb-auto-mount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(putSystemUSBAutoMountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * USBMethodsApi - functional programming interface
 * @export
 */
export const USBMethodsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = USBMethodsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get system USB auto-mount state
         * @summary Get USB auto-mounting status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemUSBAutoMount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemUSBAutoMount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['USBMethodsApi.getSystemUSBAutoMount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Enable or disable USB auto-mounting.
         * @summary Enable or disable USB auto-mounting
         * @param {PutSystemUSBAutoMountRequest} [putSystemUSBAutoMountRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putSystemUSBAutoMount(putSystemUSBAutoMountRequest?: PutSystemUSBAutoMountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putSystemUSBAutoMount(putSystemUSBAutoMountRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['USBMethodsApi.putSystemUSBAutoMount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * USBMethodsApi - factory interface
 * @export
 */
export const USBMethodsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = USBMethodsApiFp(configuration)
    return {
        /**
         * Get system USB auto-mount state
         * @summary Get USB auto-mounting status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemUSBAutoMount(options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse2> {
            return localVarFp.getSystemUSBAutoMount(options).then((request) => request(axios, basePath));
        },
        /**
         * Enable or disable USB auto-mounting.
         * @summary Enable or disable USB auto-mounting
         * @param {PutSystemUSBAutoMountRequest} [putSystemUSBAutoMountRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putSystemUSBAutoMount(putSystemUSBAutoMountRequest?: PutSystemUSBAutoMountRequest, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse2> {
            return localVarFp.putSystemUSBAutoMount(putSystemUSBAutoMountRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * USBMethodsApi - object-oriented interface
 * @export
 * @class USBMethodsApi
 * @extends {BaseAPI}
 */
export class USBMethodsApi extends BaseAPI {
    /**
     * Get system USB auto-mount state
     * @summary Get USB auto-mounting status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof USBMethodsApi
     */
    public getSystemUSBAutoMount(options?: RawAxiosRequestConfig) {
        return USBMethodsApiFp(this.configuration).getSystemUSBAutoMount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable or disable USB auto-mounting.
     * @summary Enable or disable USB auto-mounting
     * @param {PutSystemUSBAutoMountRequest} [putSystemUSBAutoMountRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof USBMethodsApi
     */
    public putSystemUSBAutoMount(putSystemUSBAutoMountRequest?: PutSystemUSBAutoMountRequest, options?: RawAxiosRequestConfig) {
        return USBMethodsApiFp(this.configuration).putSystemUSBAutoMount(putSystemUSBAutoMountRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebMethodsApi - axios parameter creator
 * @export
 */
export const WebMethodsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the background image of the latest release
         * @param {string} [version] version of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackground: async (version?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/background`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the notice info of Update Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNoticeInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/web/notice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the information about the latest release of CasaOS
         * @param {string} [version] version of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelease: async (version?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/release`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Change error status to idle
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        resetStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebMethodsApi - functional programming interface
 * @export
 */
export const WebMethodsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebMethodsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the background image of the latest release
         * @param {string} [version] version of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBackground(version?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBackground(version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebMethodsApi.getBackground']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the notice info of Update Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNoticeInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetNoticeInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNoticeInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebMethodsApi.getNoticeInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the information about the latest release of CasaOS
         * @param {string} [version] version of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelease(version?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRelease200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelease(version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebMethodsApi.getRelease']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Change error status to idle
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async resetStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebMethodsApi.resetStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebMethodsApi - factory interface
 * @export
 */
export const WebMethodsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebMethodsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the background image of the latest release
         * @param {string} [version] version of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBackground(version?: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.getBackground(version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the notice info of Update Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNoticeInfo(options?: RawAxiosRequestConfig): AxiosPromise<GetNoticeInfo200Response> {
            return localVarFp.getNoticeInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the information about the latest release of CasaOS
         * @param {string} [version] version of the release
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelease(version?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetRelease200Response> {
            return localVarFp.getRelease(version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Change error status to idle
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        resetStatus(options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
            return localVarFp.resetStatus(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebMethodsApi - object-oriented interface
 * @export
 * @class WebMethodsApi
 * @extends {BaseAPI}
 */
export class WebMethodsApi extends BaseAPI {
    /**
     * 
     * @summary Get the background image of the latest release
     * @param {string} [version] version of the release
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebMethodsApi
     */
    public getBackground(version?: string, options?: RawAxiosRequestConfig) {
        return WebMethodsApiFp(this.configuration).getBackground(version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the notice info of Update Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebMethodsApi
     */
    public getNoticeInfo(options?: RawAxiosRequestConfig) {
        return WebMethodsApiFp(this.configuration).getNoticeInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the information about the latest release of CasaOS
     * @param {string} [version] version of the release
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebMethodsApi
     */
    public getRelease(version?: string, options?: RawAxiosRequestConfig) {
        return WebMethodsApiFp(this.configuration).getRelease(version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Change error status to idle
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof WebMethodsApi
     */
    public resetStatus(options?: RawAxiosRequestConfig) {
        return WebMethodsApiFp(this.configuration).resetStatus(options).then((request) => request(this.axios, this.basePath));
    }
}



