/* tslint:disable */
/* eslint-disable */
/**
 * CasaOS Local Storage API
 * <picture>     <source media=\"(prefers-color-scheme: dark)\" srcset=\"https://raw.githubusercontent.com/IceWhaleTech/logo/main/casaos/casaos_banner_dark_night_800px.png\">     <source media=\"(prefers-color-scheme: light)\" srcset=\"https://raw.githubusercontent.com/IceWhaleTech/logo/main/casaos/casaos_banner_twilight_blue_800px.png\">     <img alt=\"CasaOS\" src=\"https://raw.githubusercontent.com/IceWhaleTech/logo/main/casaos/casaos_banner_twilight_blue_800px.png\"> </picture>  CasaOS Local Storage service manages local storage including disks, partitions and mounting points.  This API allows interacting with the service to conduct such management.  For issues and discussions, please visit the [GitHub repository](https://github.com/IceWhaleTech/CasaOS) or join [our Discord](https://discord.gg/knqAbbBbeX).
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface BaseResponse
 */
export interface BaseResponse {
    /**
     * message returned by server side if there is any
     * @type {string}
     * @memberof BaseResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Chilren
 */
export interface Chilren {
    /**
     * 
     * @type {string}
     * @memberof Chilren
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Chilren
     */
    'mount_point'?: string;
    /**
     * 
     * @type {string}
     * @memberof Chilren
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof Chilren
     */
    'storage_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Chilren
     */
    'size'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Chilren
     */
    'supported'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Chilren
     */
    'file_system'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Chilren
     */
    'raid'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Chilren
     */
    'raid_level'?: number;
}
/**
 * 
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * 
     * @type {boolean}
     * @memberof Device
     */
    'health'?: boolean;
    /**
     * Whether the disk is faulty in RAID
     * @type {boolean}
     * @memberof Device
     */
    'faulty'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'path'?: string;
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    'index'?: number;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'model'?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface Disk
 */
export interface Disk {
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    'storage_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Disk
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    'model'?: string;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    'health'?: string;
    /**
     * 
     * @type {number}
     * @memberof Disk
     */
    'temperature'?: number;
    /**
     * 
     * @type {DiskType}
     * @memberof Disk
     */
    'type'?: DiskType;
    /**
     * 
     * @type {boolean}
     * @memberof Disk
     */
    'need_format'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    'serial'?: string;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    'path'?: string;
    /**
     * 
     * @type {number}
     * @memberof Disk
     */
    'children_number'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Disk
     */
    'support'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Disk
     */
    'index'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Disk
     */
    'free'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    'usage'?: string;
    /**
     * 
     * @type {Array<Chilren>}
     * @memberof Disk
     */
    'children'?: Array<Chilren>;
    /**
     * 
     * @type {boolean}
     * @memberof Disk
     */
    'rota'?: boolean;
}


/**
 * 
 * @export
 * @interface DiskInfo
 */
export interface DiskInfo {
    /**
     * 
     * @type {Disk}
     * @memberof DiskInfo
     */
    'disk'?: Disk;
    /**
     * 
     * @type {Array<Partition>}
     * @memberof DiskInfo
     */
    'partitions'?: Array<Partition>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DiskType = {
    Hdd: 'HDD',
    Ssd: 'SSD',
    Usb: 'USB',
    Nvme: 'NVME',
    Mmc: 'MMC'
} as const;

export type DiskType = typeof DiskType[keyof typeof DiskType];


/**
 * 
 * @export
 * @interface GetDiskInfo200Response
 */
export interface GetDiskInfo200Response {
    /**
     * message returned by server side if there is any
     * @type {string}
     * @memberof GetDiskInfo200Response
     */
    'message'?: string;
    /**
     * 
     * @type {DiskInfo}
     * @memberof GetDiskInfo200Response
     */
    'data'?: DiskInfo;
}
/**
 * 
 * @export
 * @interface GetDisks200Response
 */
export interface GetDisks200Response {
    /**
     * message returned by server side if there is any
     * @type {string}
     * @memberof GetDisks200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Array<Disk>}
     * @memberof GetDisks200Response
     */
    'data'?: Array<Disk>;
}
/**
 * 
 * @export
 * @interface GetMergeInitStatus200Response
 */
export interface GetMergeInitStatus200Response {
    /**
     * message returned by server side if there is any
     * @type {string}
     * @memberof GetMergeInitStatus200Response
     */
    'message'?: string;
    /**
     * 
     * @type {MergeStatus}
     * @memberof GetMergeInitStatus200Response
     */
    'data'?: MergeStatus;
}


/**
 * 
 * @export
 * @interface GetMerges200Response
 */
export interface GetMerges200Response {
    /**
     * message returned by server side if there is any
     * @type {string}
     * @memberof GetMerges200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Array<Merge>}
     * @memberof GetMerges200Response
     */
    'data'?: Array<Merge>;
}
/**
 * 
 * @export
 * @interface GetMounts200Response
 */
export interface GetMounts200Response {
    /**
     * message returned by server side if there is any
     * @type {string}
     * @memberof GetMounts200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Array<Mount>}
     * @memberof GetMounts200Response
     */
    'data'?: Array<Mount>;
}
/**
 * 
 * @export
 * @interface GetRaids200Response
 */
export interface GetRaids200Response {
    /**
     * message returned by server side if there is any
     * @type {string}
     * @memberof GetRaids200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Array<Raid>}
     * @memberof GetRaids200Response
     */
    'data'?: Array<Raid>;
}
/**
 * 
 * @export
 * @interface GetStorage200Response
 */
export interface GetStorage200Response {
    /**
     * message returned by server side if there is any
     * @type {string}
     * @memberof GetStorage200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Array<Storage>}
     * @memberof GetStorage200Response
     */
    'data'?: Array<Storage>;
}
/**
 * 
 * @export
 * @interface Merge
 */
export interface Merge {
    /**
     * 
     * @type {number}
     * @memberof Merge
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Merge
     */
    'fstype'?: string;
    /**
     * 
     * @type {string}
     * @memberof Merge
     */
    'mount_point': string;
    /**
     * 
     * @type {string}
     * @memberof Merge
     */
    'source_base_path'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Merge
     */
    'source_volume_uuids'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Merge
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Merge
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MergeStatus = {
    Initialized: 'initialized',
    Uninitialized: 'uninitialized',
    Error: 'error'
} as const;

export type MergeStatus = typeof MergeStatus[keyof typeof MergeStatus];


/**
 * 
 * @export
 * @interface Mount
 */
export interface Mount {
    /**
     * 
     * @type {number}
     * @memberof Mount
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Mount
     */
    'mount_point': string;
    /**
     * 
     * @type {string}
     * @memberof Mount
     */
    'fstype'?: string;
    /**
     * 
     * @type {string}
     * @memberof Mount
     */
    'source'?: string;
    /**
     * 
     * @type {string}
     * @memberof Mount
     */
    'options'?: string;
    /**
     * Extended properties of the mount
     * @type {{ [key: string]: string; }}
     * @memberof Mount
     */
    'extended'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface MountPoint
 */
export interface MountPoint {
    /**
     * 
     * @type {string}
     * @memberof MountPoint
     */
    'mount_point': string;
}
/**
 * 
 * @export
 * @interface Partition
 */
export interface Partition {
    /**
     * 
     * @type {string}
     * @memberof Partition
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Partition
     */
    'size'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Partition
     */
    'supported'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Partition
     */
    'FileSystem'?: string;
}
/**
 * 
 * @export
 * @interface PostStorageBody
 */
export interface PostStorageBody {
    /**
     * 
     * @type {string}
     * @memberof PostStorageBody
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof PostStorageBody
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof PostStorageBody
     */
    'format'?: boolean;
}
/**
 * 
 * @export
 * @interface PutRaidBody
 */
export interface PutRaidBody {
    /**
     * 
     * @type {string}
     * @memberof PutRaidBody
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof PutRaidBody
     */
    'action'?: PutRaidBodyActionEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof PutRaidBody
     */
    'devices'?: Array<string>;
}

export const PutRaidBodyActionEnum = {
    Add: 'add',
    Remove: 'remove'
} as const;

export type PutRaidBodyActionEnum = typeof PutRaidBodyActionEnum[keyof typeof PutRaidBodyActionEnum];

/**
 * 
 * @export
 * @interface Raid
 */
export interface Raid {
    /**
     * 
     * @type {string}
     * @memberof Raid
     */
    'name'?: string;
    /**
     * 
     * @type {Array<Device>}
     * @memberof Raid
     */
    'devices'?: Array<Device>;
    /**
     * 
     * @type {string}
     * @memberof Raid
     */
    'mount_point'?: string;
    /**
     * 
     * @type {number}
     * @memberof Raid
     */
    'raid_level'?: number;
    /**
     * 
     * @type {number}
     * @memberof Raid
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof Raid
     */
    'used'?: number;
    /**
     * 
     * @type {number}
     * @memberof Raid
     */
    'percentage'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Raid
     */
    'shortage'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Raid
     */
    'damaged'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Raid
     */
    'finish_time'?: number;
    /**
     * 
     * @type {string}
     * @memberof Raid
     */
    'path'?: string;
    /**
     * 
     * @type {number}
     * @memberof Raid
     */
    'disk_number'?: number;
    /**
     * 
     * @type {string}
     * @memberof Raid
     */
    'status'?: RaidStatusEnum;
    /**
     * The size of the smallest disk in RAID.
     * @type {number}
     * @memberof Raid
     */
    'dev_size'?: number;
}

export const RaidStatusEnum = {
    Recover: 'recover',
    Idle: 'idle',
    Reshape: 'reshape'
} as const;

export type RaidStatusEnum = typeof RaidStatusEnum[keyof typeof RaidStatusEnum];

/**
 * 
 * @export
 * @interface RaidBody
 */
export interface RaidBody {
    /**
     * 
     * @type {Array<string>}
     * @memberof RaidBody
     */
    'devices': Array<string>;
    /**
     * 
     * @type {number}
     * @memberof RaidBody
     */
    'raid_level': RaidBodyRaidLevelEnum;
    /**
     * Whether to replace the existing /DATA directory
     * @type {boolean}
     * @memberof RaidBody
     */
    'is_default'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RaidBody
     */
    'mount_point'?: string;
    /**
     * 
     * @type {string}
     * @memberof RaidBody
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RaidBody
     */
    'path'?: string;
}

export const RaidBodyRaidLevelEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_5: 5
} as const;

export type RaidBodyRaidLevelEnum = typeof RaidBodyRaidLevelEnum[keyof typeof RaidBodyRaidLevelEnum];

/**
 * 
 * @export
 * @interface SetMerge200Response
 */
export interface SetMerge200Response {
    /**
     * message returned by server side if there is any
     * @type {string}
     * @memberof SetMerge200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Merge}
     * @memberof SetMerge200Response
     */
    'data'?: Merge;
}
/**
 * 
 * @export
 * @interface Storage
 */
export interface Storage {
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    'mount_point'?: string;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    'size'?: string;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    'avail'?: string;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    'used'?: string;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    'drive_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    'persisted_in'?: string;
    /**
     * 
     * @type {DiskType}
     * @memberof Storage
     */
    'disk_type'?: DiskType;
    /**
     * 
     * @type {boolean}
     * @memberof Storage
     */
    'raid'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Storage
     */
    'raid_level'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Storage
     */
    'health'?: boolean;
}


/**
 * 
 * @export
 * @interface StorageAggrgation
 */
export interface StorageAggrgation {
    /**
     * 
     * @type {string}
     * @memberof StorageAggrgation
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof StorageAggrgation
     */
    'font': string;
    /**
     * 
     * @type {string}
     * @memberof StorageAggrgation
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof StorageAggrgation
     */
    'type': StorageAggrgationTypeEnum;
    /**
     * extensions
     * @type {object}
     * @memberof StorageAggrgation
     */
    'extensions': object;
}

export const StorageAggrgationTypeEnum = {
    Raid: 'raid',
    System: 'system',
    Usb: 'USB',
    Disk: 'disk',
    Cloud: 'cloud',
    Smb: 'smb'
} as const;

export type StorageAggrgationTypeEnum = typeof StorageAggrgationTypeEnum[keyof typeof StorageAggrgationTypeEnum];

/**
 * 
 * @export
 * @interface UpdateMount200Response
 */
export interface UpdateMount200Response {
    /**
     * message returned by server side if there is any
     * @type {string}
     * @memberof UpdateMount200Response
     */
    'message'?: string;
    /**
     * 
     * @type {Mount}
     * @memberof UpdateMount200Response
     */
    'data'?: Mount;
}
/**
 * 
 * @export
 * @interface Volume
 */
export interface Volume {
    /**
     * 
     * @type {number}
     * @memberof Volume
     */
    'id'?: number;
    /**
     * (TODO)
     * @type {string}
     * @memberof Volume
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof Volume
     */
    'path': string;
    /**
     * (TODO)
     * @type {number}
     * @memberof Volume
     */
    'state'?: number;
    /**
     * 
     * @type {string}
     * @memberof Volume
     */
    'mount_point': string;
    /**
     * 
     * @type {string}
     * @memberof Volume
     */
    'created_at'?: string;
}

/**
 * DiskMethodsApi - axios parameter creator
 * @export
 */
export const DiskMethodsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of all disks, or a single disk by path.
         * @summary Get disk info
         * @param {string} [path] Filter the results by path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiskInfo: async (path?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/disk/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all disks, or a single disk by path.
         * @summary Get disks
         * @param {string} [free] Filter the results by path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisks: async (free?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/disk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (free !== undefined) {
                localVarQueryParameter['free'] = free;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DiskMethodsApi - functional programming interface
 * @export
 */
export const DiskMethodsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DiskMethodsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of all disks, or a single disk by path.
         * @summary Get disk info
         * @param {string} [path] Filter the results by path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDiskInfo(path?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDiskInfo200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDiskInfo(path, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DiskMethodsApi.getDiskInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of all disks, or a single disk by path.
         * @summary Get disks
         * @param {string} [free] Filter the results by path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDisks(free?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDisks200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDisks(free, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DiskMethodsApi.getDisks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DiskMethodsApi - factory interface
 * @export
 */
export const DiskMethodsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DiskMethodsApiFp(configuration)
    return {
        /**
         * Get a list of all disks, or a single disk by path.
         * @summary Get disk info
         * @param {string} [path] Filter the results by path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiskInfo(path?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetDiskInfo200Response> {
            return localVarFp.getDiskInfo(path, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all disks, or a single disk by path.
         * @summary Get disks
         * @param {string} [free] Filter the results by path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisks(free?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetDisks200Response> {
            return localVarFp.getDisks(free, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DiskMethodsApi - object-oriented interface
 * @export
 * @class DiskMethodsApi
 * @extends {BaseAPI}
 */
export class DiskMethodsApi extends BaseAPI {
    /**
     * Get a list of all disks, or a single disk by path.
     * @summary Get disk info
     * @param {string} [path] Filter the results by path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiskMethodsApi
     */
    public getDiskInfo(path?: string, options?: RawAxiosRequestConfig) {
        return DiskMethodsApiFp(this.configuration).getDiskInfo(path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all disks, or a single disk by path.
     * @summary Get disks
     * @param {string} [free] Filter the results by path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiskMethodsApi
     */
    public getDisks(free?: string, options?: RawAxiosRequestConfig) {
        return DiskMethodsApiFp(this.configuration).getDisks(free, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MergeMethodsApi - axios parameter creator
 * @export
 */
export const MergeMethodsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * (TODO)
         * @summary Get merge initialization status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMergeInitStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/merge/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (TODO)
         * @summary Get merges
         * @param {string} [mountPoint] Filter the results by mount point
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerges: async (mountPoint?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/merge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (mountPoint !== undefined) {
                localVarQueryParameter['mount_point'] = mountPoint;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (TODO)
         * @summary Initialize a merge
         * @param {MountPoint} mountPoint 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initMerge: async (mountPoint: MountPoint, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mountPoint' is not null or undefined
            assertParamExists('initMerge', 'mountPoint', mountPoint)
            const localVarPath = `/merge/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mountPoint, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (TODO)
         * @summary Set a merge
         * @param {Merge} merge 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMerge: async (merge: Merge, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'merge' is not null or undefined
            assertParamExists('setMerge', 'merge', merge)
            const localVarPath = `/merge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(merge, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MergeMethodsApi - functional programming interface
 * @export
 */
export const MergeMethodsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MergeMethodsApiAxiosParamCreator(configuration)
    return {
        /**
         * (TODO)
         * @summary Get merge initialization status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMergeInitStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMergeInitStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMergeInitStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MergeMethodsApi.getMergeInitStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * (TODO)
         * @summary Get merges
         * @param {string} [mountPoint] Filter the results by mount point
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMerges(mountPoint?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMerges200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMerges(mountPoint, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MergeMethodsApi.getMerges']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * (TODO)
         * @summary Initialize a merge
         * @param {MountPoint} mountPoint 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initMerge(mountPoint: MountPoint, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMergeInitStatus200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initMerge(mountPoint, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MergeMethodsApi.initMerge']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * (TODO)
         * @summary Set a merge
         * @param {Merge} merge 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setMerge(merge: Merge, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetMerge200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setMerge(merge, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MergeMethodsApi.setMerge']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MergeMethodsApi - factory interface
 * @export
 */
export const MergeMethodsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MergeMethodsApiFp(configuration)
    return {
        /**
         * (TODO)
         * @summary Get merge initialization status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMergeInitStatus(options?: RawAxiosRequestConfig): AxiosPromise<GetMergeInitStatus200Response> {
            return localVarFp.getMergeInitStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * (TODO)
         * @summary Get merges
         * @param {string} [mountPoint] Filter the results by mount point
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerges(mountPoint?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetMerges200Response> {
            return localVarFp.getMerges(mountPoint, options).then((request) => request(axios, basePath));
        },
        /**
         * (TODO)
         * @summary Initialize a merge
         * @param {MountPoint} mountPoint 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initMerge(mountPoint: MountPoint, options?: RawAxiosRequestConfig): AxiosPromise<GetMergeInitStatus200Response> {
            return localVarFp.initMerge(mountPoint, options).then((request) => request(axios, basePath));
        },
        /**
         * (TODO)
         * @summary Set a merge
         * @param {Merge} merge 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMerge(merge: Merge, options?: RawAxiosRequestConfig): AxiosPromise<SetMerge200Response> {
            return localVarFp.setMerge(merge, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MergeMethodsApi - object-oriented interface
 * @export
 * @class MergeMethodsApi
 * @extends {BaseAPI}
 */
export class MergeMethodsApi extends BaseAPI {
    /**
     * (TODO)
     * @summary Get merge initialization status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MergeMethodsApi
     */
    public getMergeInitStatus(options?: RawAxiosRequestConfig) {
        return MergeMethodsApiFp(this.configuration).getMergeInitStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * (TODO)
     * @summary Get merges
     * @param {string} [mountPoint] Filter the results by mount point
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MergeMethodsApi
     */
    public getMerges(mountPoint?: string, options?: RawAxiosRequestConfig) {
        return MergeMethodsApiFp(this.configuration).getMerges(mountPoint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * (TODO)
     * @summary Initialize a merge
     * @param {MountPoint} mountPoint 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MergeMethodsApi
     */
    public initMerge(mountPoint: MountPoint, options?: RawAxiosRequestConfig) {
        return MergeMethodsApiFp(this.configuration).initMerge(mountPoint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * (TODO)
     * @summary Set a merge
     * @param {Merge} merge 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MergeMethodsApi
     */
    public setMerge(merge: Merge, options?: RawAxiosRequestConfig) {
        return MergeMethodsApiFp(this.configuration).setMerge(merge, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MountMethodsApi - axios parameter creator
 * @export
 */
export const MountMethodsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all volumes currently mounted on the system. Volumes can be filtered by corresponding query parameters.
         * @summary Get mounted volumes
         * @param {string} [id] Filter the results by id
         * @param {string} [mountPoint] Filter the results by mount point
         * @param {string} [type] Filter the results by type
         * @param {string} [source] Filter the results by source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMounts: async (id?: string, mountPoint?: string, type?: string, source?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (mountPoint !== undefined) {
                localVarQueryParameter['mount_point'] = mountPoint;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (TODO)
         * @summary Mount a volume
         * @param {Mount} mount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mount: async (mount: Mount, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mount' is not null or undefined
            assertParamExists('mount', 'mount', mount)
            const localVarPath = `/mount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * (TODO)
         * @summary Umount volume
         * @param {string} mountPoint Filter the results by mount point
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umount: async (mountPoint: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mountPoint' is not null or undefined
            assertParamExists('umount', 'mountPoint', mountPoint)
            const localVarPath = `/mount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (mountPoint !== undefined) {
                localVarQueryParameter['mount_point'] = mountPoint;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updating a mount volume is equivalent to unmounting the volume and mounting it again with the new parameters.
         * @summary Update a mount volume
         * @param {string} mountPoint Filter the results by mount point
         * @param {Mount} mount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMount: async (mountPoint: string, mount: Mount, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mountPoint' is not null or undefined
            assertParamExists('updateMount', 'mountPoint', mountPoint)
            // verify required parameter 'mount' is not null or undefined
            assertParamExists('updateMount', 'mount', mount)
            const localVarPath = `/mount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (mountPoint !== undefined) {
                localVarQueryParameter['mount_point'] = mountPoint;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MountMethodsApi - functional programming interface
 * @export
 */
export const MountMethodsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MountMethodsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all volumes currently mounted on the system. Volumes can be filtered by corresponding query parameters.
         * @summary Get mounted volumes
         * @param {string} [id] Filter the results by id
         * @param {string} [mountPoint] Filter the results by mount point
         * @param {string} [type] Filter the results by type
         * @param {string} [source] Filter the results by source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMounts(id?: string, mountPoint?: string, type?: string, source?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMounts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMounts(id, mountPoint, type, source, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MountMethodsApi.getMounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * (TODO)
         * @summary Mount a volume
         * @param {Mount} mount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mount(mount: Mount, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateMount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mount(mount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MountMethodsApi.mount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * (TODO)
         * @summary Umount volume
         * @param {string} mountPoint Filter the results by mount point
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async umount(mountPoint: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.umount(mountPoint, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MountMethodsApi.umount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updating a mount volume is equivalent to unmounting the volume and mounting it again with the new parameters.
         * @summary Update a mount volume
         * @param {string} mountPoint Filter the results by mount point
         * @param {Mount} mount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMount(mountPoint: string, mount: Mount, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateMount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMount(mountPoint, mount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MountMethodsApi.updateMount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MountMethodsApi - factory interface
 * @export
 */
export const MountMethodsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MountMethodsApiFp(configuration)
    return {
        /**
         * Get all volumes currently mounted on the system. Volumes can be filtered by corresponding query parameters.
         * @summary Get mounted volumes
         * @param {string} [id] Filter the results by id
         * @param {string} [mountPoint] Filter the results by mount point
         * @param {string} [type] Filter the results by type
         * @param {string} [source] Filter the results by source
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMounts(id?: string, mountPoint?: string, type?: string, source?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetMounts200Response> {
            return localVarFp.getMounts(id, mountPoint, type, source, options).then((request) => request(axios, basePath));
        },
        /**
         * (TODO)
         * @summary Mount a volume
         * @param {Mount} mount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mount(mount: Mount, options?: RawAxiosRequestConfig): AxiosPromise<UpdateMount200Response> {
            return localVarFp.mount(mount, options).then((request) => request(axios, basePath));
        },
        /**
         * (TODO)
         * @summary Umount volume
         * @param {string} mountPoint Filter the results by mount point
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        umount(mountPoint: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
            return localVarFp.umount(mountPoint, options).then((request) => request(axios, basePath));
        },
        /**
         * Updating a mount volume is equivalent to unmounting the volume and mounting it again with the new parameters.
         * @summary Update a mount volume
         * @param {string} mountPoint Filter the results by mount point
         * @param {Mount} mount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMount(mountPoint: string, mount: Mount, options?: RawAxiosRequestConfig): AxiosPromise<UpdateMount200Response> {
            return localVarFp.updateMount(mountPoint, mount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MountMethodsApi - object-oriented interface
 * @export
 * @class MountMethodsApi
 * @extends {BaseAPI}
 */
export class MountMethodsApi extends BaseAPI {
    /**
     * Get all volumes currently mounted on the system. Volumes can be filtered by corresponding query parameters.
     * @summary Get mounted volumes
     * @param {string} [id] Filter the results by id
     * @param {string} [mountPoint] Filter the results by mount point
     * @param {string} [type] Filter the results by type
     * @param {string} [source] Filter the results by source
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MountMethodsApi
     */
    public getMounts(id?: string, mountPoint?: string, type?: string, source?: string, options?: RawAxiosRequestConfig) {
        return MountMethodsApiFp(this.configuration).getMounts(id, mountPoint, type, source, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * (TODO)
     * @summary Mount a volume
     * @param {Mount} mount 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MountMethodsApi
     */
    public mount(mount: Mount, options?: RawAxiosRequestConfig) {
        return MountMethodsApiFp(this.configuration).mount(mount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * (TODO)
     * @summary Umount volume
     * @param {string} mountPoint Filter the results by mount point
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MountMethodsApi
     */
    public umount(mountPoint: string, options?: RawAxiosRequestConfig) {
        return MountMethodsApiFp(this.configuration).umount(mountPoint, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updating a mount volume is equivalent to unmounting the volume and mounting it again with the new parameters.
     * @summary Update a mount volume
     * @param {string} mountPoint Filter the results by mount point
     * @param {Mount} mount 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MountMethodsApi
     */
    public updateMount(mountPoint: string, mount: Mount, options?: RawAxiosRequestConfig) {
        return MountMethodsApiFp(this.configuration).updateMount(mountPoint, mount, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RaidMethodsApi - axios parameter creator
 * @export
 */
export const RaidMethodsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a raid
         * @summary create a raid
         * @param {RaidBody} raidBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRaid: async (raidBody: RaidBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'raidBody' is not null or undefined
            assertParamExists('createRaid', 'raidBody', raidBody)
            const localVarPath = `/raid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(raidBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a raid by path
         * @summary Delete a raid
         * @param {string} path Filter the delete by raid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRaid: async (path: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'path' is not null or undefined
            assertParamExists('deleteRaid', 'path', path)
            const localVarPath = `/raid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all raids, or a single raid by name.
         * @summary Get raids
         * @param {string} [path] Filter the results by raid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaids: async (path?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/raid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update raid-related configurations by name
         * @summary Update a raid
         * @param {PutRaidBody} putRaidBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRaid: async (putRaidBody: PutRaidBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'putRaidBody' is not null or undefined
            assertParamExists('updateRaid', 'putRaidBody', putRaidBody)
            const localVarPath = `/raid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(putRaidBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RaidMethodsApi - functional programming interface
 * @export
 */
export const RaidMethodsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RaidMethodsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a raid
         * @summary create a raid
         * @param {RaidBody} raidBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRaid(raidBody: RaidBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Raid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRaid(raidBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaidMethodsApi.createRaid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a raid by path
         * @summary Delete a raid
         * @param {string} path Filter the delete by raid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRaid(path: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRaid(path, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaidMethodsApi.deleteRaid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of all raids, or a single raid by name.
         * @summary Get raids
         * @param {string} [path] Filter the results by raid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRaids(path?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRaids200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRaids(path, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaidMethodsApi.getRaids']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update raid-related configurations by name
         * @summary Update a raid
         * @param {PutRaidBody} putRaidBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRaid(putRaidBody: PutRaidBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Raid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRaid(putRaidBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RaidMethodsApi.updateRaid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RaidMethodsApi - factory interface
 * @export
 */
export const RaidMethodsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RaidMethodsApiFp(configuration)
    return {
        /**
         * Create a raid
         * @summary create a raid
         * @param {RaidBody} raidBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRaid(raidBody: RaidBody, options?: RawAxiosRequestConfig): AxiosPromise<Raid> {
            return localVarFp.createRaid(raidBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a raid by path
         * @summary Delete a raid
         * @param {string} path Filter the delete by raid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRaid(path: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
            return localVarFp.deleteRaid(path, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all raids, or a single raid by name.
         * @summary Get raids
         * @param {string} [path] Filter the results by raid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRaids(path?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetRaids200Response> {
            return localVarFp.getRaids(path, options).then((request) => request(axios, basePath));
        },
        /**
         * Update raid-related configurations by name
         * @summary Update a raid
         * @param {PutRaidBody} putRaidBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRaid(putRaidBody: PutRaidBody, options?: RawAxiosRequestConfig): AxiosPromise<Raid> {
            return localVarFp.updateRaid(putRaidBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RaidMethodsApi - object-oriented interface
 * @export
 * @class RaidMethodsApi
 * @extends {BaseAPI}
 */
export class RaidMethodsApi extends BaseAPI {
    /**
     * Create a raid
     * @summary create a raid
     * @param {RaidBody} raidBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaidMethodsApi
     */
    public createRaid(raidBody: RaidBody, options?: RawAxiosRequestConfig) {
        return RaidMethodsApiFp(this.configuration).createRaid(raidBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a raid by path
     * @summary Delete a raid
     * @param {string} path Filter the delete by raid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaidMethodsApi
     */
    public deleteRaid(path: string, options?: RawAxiosRequestConfig) {
        return RaidMethodsApiFp(this.configuration).deleteRaid(path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all raids, or a single raid by name.
     * @summary Get raids
     * @param {string} [path] Filter the results by raid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaidMethodsApi
     */
    public getRaids(path?: string, options?: RawAxiosRequestConfig) {
        return RaidMethodsApiFp(this.configuration).getRaids(path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update raid-related configurations by name
     * @summary Update a raid
     * @param {PutRaidBody} putRaidBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RaidMethodsApi
     */
    public updateRaid(putRaidBody: PutRaidBody, options?: RawAxiosRequestConfig) {
        return RaidMethodsApiFp(this.configuration).updateRaid(putRaidBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StorageMethodsApi - axios parameter creator
 * @export
 */
export const StorageMethodsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a storage
         * @summary Create a storage
         * @param {PostStorageBody} postStorageBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStorage: async (postStorageBody: PostStorageBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'postStorageBody' is not null or undefined
            assertParamExists('createStorage', 'postStorageBody', postStorageBody)
            const localVarPath = `/storage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postStorageBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a storage by path
         * @summary Delete a storage
         * @param {string} path Filter the delete by path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStorage: async (path: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'path' is not null or undefined
            assertParamExists('deleteStorage', 'path', path)
            const localVarPath = `/storage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all storage, or a single storage by path.
         * @summary Get all storages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllStorages: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/storages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all storage, or a single storage by path.
         * @summary Get storages
         * @param {string} [system] Whether system storage is required
         * @param {string} [path] Filter the results by path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorage: async (system?: string, path?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/storage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (system !== undefined) {
                localVarQueryParameter['system'] = system;
            }

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StorageMethodsApi - functional programming interface
 * @export
 */
export const StorageMethodsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StorageMethodsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a storage
         * @summary Create a storage
         * @param {PostStorageBody} postStorageBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStorage(postStorageBody: PostStorageBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostStorageBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStorage(postStorageBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StorageMethodsApi.createStorage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a storage by path
         * @summary Delete a storage
         * @param {string} path Filter the delete by path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStorage(path: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStorage(path, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StorageMethodsApi.deleteStorage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of all storage, or a single storage by path.
         * @summary Get all storages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllStorages(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StorageAggrgation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllStorages(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StorageMethodsApi.getAllStorages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of all storage, or a single storage by path.
         * @summary Get storages
         * @param {string} [system] Whether system storage is required
         * @param {string} [path] Filter the results by path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStorage(system?: string, path?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStorage200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStorage(system, path, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StorageMethodsApi.getStorage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StorageMethodsApi - factory interface
 * @export
 */
export const StorageMethodsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StorageMethodsApiFp(configuration)
    return {
        /**
         * Create a storage
         * @summary Create a storage
         * @param {PostStorageBody} postStorageBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStorage(postStorageBody: PostStorageBody, options?: RawAxiosRequestConfig): AxiosPromise<PostStorageBody> {
            return localVarFp.createStorage(postStorageBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a storage by path
         * @summary Delete a storage
         * @param {string} path Filter the delete by path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStorage(path: string, options?: RawAxiosRequestConfig): AxiosPromise<BaseResponse> {
            return localVarFp.deleteStorage(path, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all storage, or a single storage by path.
         * @summary Get all storages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllStorages(options?: RawAxiosRequestConfig): AxiosPromise<Array<StorageAggrgation>> {
            return localVarFp.getAllStorages(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all storage, or a single storage by path.
         * @summary Get storages
         * @param {string} [system] Whether system storage is required
         * @param {string} [path] Filter the results by path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorage(system?: string, path?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetStorage200Response> {
            return localVarFp.getStorage(system, path, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StorageMethodsApi - object-oriented interface
 * @export
 * @class StorageMethodsApi
 * @extends {BaseAPI}
 */
export class StorageMethodsApi extends BaseAPI {
    /**
     * Create a storage
     * @summary Create a storage
     * @param {PostStorageBody} postStorageBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageMethodsApi
     */
    public createStorage(postStorageBody: PostStorageBody, options?: RawAxiosRequestConfig) {
        return StorageMethodsApiFp(this.configuration).createStorage(postStorageBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a storage by path
     * @summary Delete a storage
     * @param {string} path Filter the delete by path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageMethodsApi
     */
    public deleteStorage(path: string, options?: RawAxiosRequestConfig) {
        return StorageMethodsApiFp(this.configuration).deleteStorage(path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all storage, or a single storage by path.
     * @summary Get all storages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageMethodsApi
     */
    public getAllStorages(options?: RawAxiosRequestConfig) {
        return StorageMethodsApiFp(this.configuration).getAllStorages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all storage, or a single storage by path.
     * @summary Get storages
     * @param {string} [system] Whether system storage is required
     * @param {string} [path] Filter the results by path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageMethodsApi
     */
    public getStorage(system?: string, path?: string, options?: RawAxiosRequestConfig) {
        return StorageMethodsApiFp(this.configuration).getStorage(system, path, options).then((request) => request(this.axios, this.basePath));
    }
}



